{"version":3,"sources":["webpack:///Editor.js","webpack:///webpack/bootstrap a77038209ac687b469b6","webpack:///./src/scripts/app/EditorUI.coffee","webpack:///external \"TweenTime.Editor\"","webpack:///external \"d3\"","webpack:///./src/scripts/vendors/three.js-extras/Projector.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","bind","fn","me","apply","arguments","require","EditorUI","THREE","TweenTimeEditor","d3","window","this","initAdd","initRemove","onMenuCreated","$container","getRaycaster","mouse","offset","plane","projector","selectedObject","selectedObjectPos","tweenTime","editor","json_replacer","key","val","$","app","containerWebgl","Vector3","Projector","Vector2","Mesh","PlaneBufferGeometry","MeshBasicMaterial","color","opacity","transparent","visible","_this","camera","raycaster","vector","activeCamera","x","y","unproject","Raycaster","position","sub","normalize","mousedown","e","element","intersects","preventDefault","intersectObjects","scene","children","length","object","_data","selectionManager","select","clone","intersectObject","copy","point","mouseup","mousemove","pos","posDiff","prop_x","prop_y","clientX","width","clientY","height","getProperty","add","setValue","_isDirty","timeline","prototype","$el","append","prepend","data","self","find","click","datum","i","index","item","len","ref","selection","indexOf","type","splice","destroy","reset","render","$link","element_name","elements","ElementFactory","all_data","current_time","label","next_id","timer","time","isDirty","start","end","collapsed","properties","getTypeProperties","push","undefined",4,"TweenTime","Editor",5,15,"RenderableObject","z","RenderableFace","v1","RenderableVertex","v2","v3","normalModel","vertexNormalsModel","vertexNormalsLength","Color","material","uvs","positionWorld","positionScreen","Vector4","vertex","RenderableLine","vertexColors","RenderableSprite","rotation","scale","getNextObjectInPool","_objectCount","_objectPoolLength","_objectPool","getNextVertexInPool","_vertexCount","_vertexPoolLength","_vertexPool","getNextFaceInPool","_faceCount","_facePoolLength","face","_facePool","getNextLineInPool","_lineCount","_linePoolLength","line","_linePool","getNextSpriteInPool","_spriteCount","_spritePoolLength","sprite","_spritePool","painterSort","a","b","clipLine","s1","s2","alpha1","alpha2","bc1near","w","bc2near","bc1far","bc2far","Math","max","min","lerp","_object","_vertex","_face","_line","_sprite","_modelMatrix","_renderData","objects","lights","_vector3","_vector4","_clipBox","Box3","_boundingBox","_points3","Array","_viewMatrix","Matrix4","_viewProjectionMatrix","_modelViewProjectionMatrix","_normalMatrix","Matrix3","_frustum","Frustum","_clippedVertex1PositionScreen","_clippedVertex2PositionScreen","projectVector","console","warn","project","unprojectVector","pickingRay","error","RenderList","normals","normalMatrix","setObject","value","getNormalMatrix","matrixWorld","projectVertex","applyMatrix4","invW","pushVertex","set","pushNormal","pushUv","checkTriangleVisibility","isIntersectionBox","setFromPoints","checkBackfaceCulling","pushLine","pushTriangle","side","DoubleSide","normal","applyMatrix3","offset2","uv","renderList","projectScene","sortObjects","sortElements","autoUpdate","updateMatrixWorld","parent","matrixWorldInverse","getInverse","multiplyMatrices","projectionMatrix","setFromMatrix","traverseVisible","Light","Line","Sprite","frustumCulled","intersectsObject","setFromMatrixPosition","applyProjection","sort","o","ol","geometry","BufferGeometry","attributes","offsets","positions","array","l","indices","count","Geometry","vertices","faces","faceVertexUvs","isFaceMaterial","MeshFaceMaterial","objectMaterials","v","vl","morphTargets","morphInfluences","morphTargetInfluences","t","tl","influence","target","targetVertex","f","fl","materials","materialIndex","FrontSide","BackSide","negate","faceVertexNormals","vertexNormals","n","nl","vertexUvs","u","step","mode","LinePieces","multiplyScalar","VertexColors","colors","abs"],"mappings":"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","file":"Editor.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"assets/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t  var EditorUI, THREE, TweenTimeEditor, d3;\n\t  THREE = window.THREE;\n\t  TweenTimeEditor = __webpack_require__(4);\n\t  __webpack_require__(15);\n\t  d3 = __webpack_require__(5);\n\t  return window.EditorUI = EditorUI = (function() {\n\t    function EditorUI() {\n\t      this.initAdd = bind(this.initAdd, this);\n\t      this.initRemove = bind(this.initRemove, this);\n\t      this.onMenuCreated = bind(this.onMenuCreated, this);\n\t      var $container, getRaycaster, mouse, offset, plane, projector, selectedObject, selectedObjectPos;\n\t      this.tweenTime = window.tweenTime;\n\t      this.editor = new TweenTimeEditor(this.tweenTime, {\n\t        json_replacer: function(key, val) {\n\t          if (key === 'container') {\n\t            return void 0;\n\t          }\n\t          if (key === 'parent') {\n\t            return void 0;\n\t          }\n\t          if (key === 'children') {\n\t            return void 0;\n\t          }\n\t          if (key === 'object') {\n\t            return void 0;\n\t          }\n\t          if (key === 'classObject') {\n\t            return void 0;\n\t          }\n\t          return val;\n\t        }\n\t      });\n\t      this.onMenuCreated($('.timeline__menu'));\n\t      $container = $(window.app.containerWebgl);\n\t      offset = new THREE.Vector3();\n\t      projector = new THREE.Projector();\n\t      mouse = new THREE.Vector2();\n\t      selectedObject = false;\n\t      selectedObjectPos = new THREE.Vector3();\n\t      plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(3000, 2000, 8, 8), new THREE.MeshBasicMaterial({\n\t        color: 0xff0000,\n\t        opacity: 0.25,\n\t        transparent: true\n\t      }));\n\t      plane.visible = false;\n\t      getRaycaster = (function(_this) {\n\t        return function() {\n\t          var camera, raycaster, vector;\n\t          camera = window.activeCamera;\n\t          vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);\n\t          raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());\n\t          return raycaster;\n\t        };\n\t      })(this);\n\t      $container.mousedown((function(_this) {\n\t        return function(e) {\n\t          var element, intersects, raycaster;\n\t          e.preventDefault();\n\t          raycaster = getRaycaster();\n\t          intersects = raycaster.intersectObjects(window.app.scene.children);\n\t          if (intersects.length) {\n\t            element = intersects[0].object;\n\t            if (element._data) {\n\t              _this.editor.selectionManager.select(element._data);\n\t              selectedObject = element;\n\t              selectedObjectPos = selectedObject.position.clone();\n\t              intersects = raycaster.intersectObject(plane);\n\t              return offset.copy(intersects[0].point).sub(plane.position);\n\t            }\n\t          }\n\t        };\n\t      })(this));\n\t      $(window).mouseup((function(_this) {\n\t        return function(e) {\n\t          return selectedObject = false;\n\t        };\n\t      })(this));\n\t      $container.mousemove((function(_this) {\n\t        return function(e) {\n\t          var intersects, pos, posDiff, prop_x, prop_y, raycaster;\n\t          mouse.x = (e.clientX / $container.width()) * 2 - 1;\n\t          mouse.y = -(e.clientY / $container.height()) * 2 + 1;\n\t          if (!selectedObject) {\n\t            return;\n\t          }\n\t          if (!selectedObject._data) {\n\t            return;\n\t          }\n\t          prop_x = _this.tweenTime.getProperty('x', selectedObject._data);\n\t          prop_y = _this.tweenTime.getProperty('y', selectedObject._data);\n\t          raycaster = getRaycaster();\n\t          intersects = raycaster.intersectObject(plane);\n\t          pos = intersects[0].point.sub(offset);\n\t          posDiff = selectedObjectPos.clone().add(pos);\n\t          _this.tweenTime.setValue(prop_x, posDiff.x);\n\t          _this.tweenTime.setValue(prop_y, posDiff.y);\n\t          selectedObject._data._isDirty = true;\n\t          return _this.editor.timeline._isDirty = true;\n\t        };\n\t      })(this));\n\t    }\n\t\n\t    EditorUI.prototype.onMenuCreated = function($el) {\n\t      $el.append('<a class=\"menu-item menu-item--remove\">Remove</a>');\n\t      $el.prepend('<span class=\"menu-item\">Add<div class=\"submenu submenu--add\"></div></span>');\n\t      this.initAdd($el);\n\t      return this.initRemove($el);\n\t    };\n\t\n\t    EditorUI.prototype.initRemove = function($el) {\n\t      var data, selectionManager, self;\n\t      self = this;\n\t      selectionManager = self.editor.selectionManager;\n\t      data = window.tweenTime.data;\n\t      $el.find('.menu-item--remove').click(function(e) {\n\t        var datum, i, index, item, len, ref;\n\t        e.preventDefault();\n\t        ref = selectionManager.selection;\n\t        for (i = 0, len = ref.length; i < len; i++) {\n\t          item = ref[i];\n\t          datum = d3.select(item).datum();\n\t          index = data.indexOf(datum);\n\t          if (datum && datum.type && datum.id && index > -1) {\n\t            data.splice(index, 1);\n\t            if (datum.object) {\n\t              datum.object.destroy();\n\t              delete datum.object;\n\t            }\n\t          }\n\t        }\n\t        selectionManager.reset();\n\t        self.editor.render(false, false, true);\n\t      });\n\t    };\n\t\n\t    EditorUI.prototype.initAdd = function($el) {\n\t      var $container, $link, element, element_name, elements, self;\n\t      if (!window.ElementFactory) {\n\t        return;\n\t      }\n\t      $container = $el.find('.submenu--add');\n\t      elements = window.ElementFactory.elements;\n\t      self = this;\n\t      for (element_name in elements) {\n\t        element = elements[element_name];\n\t        $link = $('<a href=\"#\" data-key=\"' + element_name + '\">' + element_name + '</a>');\n\t        $container.append($link);\n\t      }\n\t      $container.find('a').click(function(e) {\n\t        var all_data, current_time, data, id, label, next_id;\n\t        e.preventDefault();\n\t        element_name = $(this).data('key');\n\t        if (ElementFactory.elements[element_name]) {\n\t          all_data = self.tweenTime.data;\n\t          next_id = all_data.length + 1;\n\t          id = \"item\" + next_id;\n\t          label = element_name + \" \" + next_id;\n\t          current_time = self.tweenTime.timer.time[0] / 1000;\n\t          data = {\n\t            isDirty: true,\n\t            id: id,\n\t            label: label,\n\t            type: element_name,\n\t            start: current_time,\n\t            end: current_time + 2,\n\t            collapsed: false,\n\t            properties: ElementFactory.getTypeProperties(element_name)\n\t          };\n\t          self.tweenTime.data.push(data);\n\t          self.editor.timeline._isDirty = true;\n\t        }\n\t      });\n\t    };\n\t\n\t    return EditorUI;\n\t\n\t  })();\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n\n/***/ 4:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = TweenTime.Editor;\n\n/***/ },\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = d3;\n\n/***/ },\n\n/***/ 15:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author julianwa / https://github.com/julianwa\n\t */\n\t\n\tTHREE.RenderableObject = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableFace = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\tthis.v3 = new THREE.RenderableVertex();\n\t\n\t\tthis.normalModel = new THREE.Vector3();\n\t\n\t\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\t\tthis.vertexNormalsLength = 0;\n\t\n\t\tthis.color = new THREE.Color();\n\t\tthis.material = null;\n\t\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\t\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableVertex = function () {\n\t\n\t\tthis.position = new THREE.Vector3();\n\t\tthis.positionWorld = new THREE.Vector3();\n\t\tthis.positionScreen = new THREE.Vector4();\n\t\n\t\tthis.visible = true;\n\t\n\t};\n\t\n\tTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\t\n\t\tthis.positionWorld.copy( vertex.positionWorld );\n\t\tthis.positionScreen.copy( vertex.positionScreen );\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableLine = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\n\t\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\t\tthis.material = null;\n\t\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableSprite = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.z = 0;\n\t\n\t\tthis.rotation = 0;\n\t\tthis.scale = new THREE.Vector2();\n\t\n\t\tthis.material = null;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Projector = function () {\n\t\n\t\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\t\n\t\t_renderData = { objects: [], lights: [], elements: [] },\n\t\n\t\t_vector3 = new THREE.Vector3(),\n\t\t_vector4 = new THREE.Vector4(),\n\t\n\t\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t\t_boundingBox = new THREE.Box3(),\n\t\t_points3 = new Array( 3 ),\n\t\t_points4 = new Array( 4 ),\n\t\n\t\t_viewMatrix = new THREE.Matrix4(),\n\t\t_viewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_modelMatrix,\n\t\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_normalMatrix = new THREE.Matrix3(),\n\t\n\t\t_frustum = new THREE.Frustum(),\n\t\n\t\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\t\n\t\t//\n\t\n\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\t\n\t\t};\n\t\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\t\n\t\t};\n\t\n\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar RenderList = function () {\n\t\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar object = null;\n\t\t\tvar material = null;\n\t\n\t\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\t\tvar setObject = function ( value ) {\n\t\n\t\t\t\tobject = value;\n\t\t\t\tmaterial = object.material;\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\t\n\t\t\t\tnormals.length = 0;\n\t\t\t\tuvs.length = 0;\n\t\n\t\t\t};\n\t\n\t\t\tvar projectVertex = function ( vertex ) {\n\t\n\t\t\t\tvar position = vertex.position;\n\t\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\t\tvar positionScreen = vertex.positionScreen;\n\t\n\t\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\tvar invW = 1 / positionScreen.w;\n\t\n\t\t\t\tpositionScreen.x *= invW;\n\t\t\t\tpositionScreen.y *= invW;\n\t\t\t\tpositionScreen.z *= invW;\n\t\n\t\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\t\n\t\t\t};\n\t\n\t\t\tvar pushVertex = function ( x, y, z ) {\n\t\n\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t_vertex.position.set( x, y, z );\n\t\n\t\t\t\tprojectVertex( _vertex );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushNormal = function ( x, y, z ) {\n\t\n\t\t\t\tnormals.push( x, y, z );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushUv = function ( x, y ) {\n\t\n\t\t\t\tuvs.push( x, y );\n\t\n\t\t\t};\n\t\n\t\t\tvar checkTriangleVisibility = function ( v1, v2, v3 ) {\n\t\n\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\t\n\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\t\n\t\t\t\treturn _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) );\n\t\n\t\t\t};\n\t\n\t\t\tvar checkBackfaceCulling = function ( v1, v2, v3 ) {\n\t\n\t\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\t\n\t\t\t};\n\t\n\t\t\tvar pushLine = function ( a, b ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\n\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t_line.id = object.id;\n\t\t\t\t_line.v1.copy( v1 );\n\t\t\t\t_line.v2.copy( v2 );\n\t\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\t\n\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushTriangle = function ( a, b, c ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\t\tvar v3 = _vertexPool[ c ];\n\t\n\t\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\t\n\t\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\t\n\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\tvar offset = arguments[ i ] * 3;\n\t\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\t\n\t\t\t\t\t\tnormal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\tvar offset2 = arguments[ i ] * 2;\n\t\n\t\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\t\tuv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_face.vertexNormalsLength = 3;\n\t\n\t\t\t\t\t_face.material = object.material;\n\t\n\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\treturn {\n\t\t\t\tsetObject: setObject,\n\t\t\t\tprojectVertex: projectVertex,\n\t\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\t\tpushVertex: pushVertex,\n\t\t\t\tpushNormal: pushNormal,\n\t\t\t\tpushUv: pushUv,\n\t\t\t\tpushLine: pushLine,\n\t\t\t\tpushTriangle: pushTriangle\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar renderList = new RenderList();\n\t\n\t\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\t\n\t\t\t_faceCount = 0;\n\t\t\t_lineCount = 0;\n\t\t\t_spriteCount = 0;\n\t\n\t\t\t_renderData.elements.length = 0;\n\t\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\t\n\t\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\t\n\t\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\t\n\t\t\t//\n\t\n\t\t\t_objectCount = 0;\n\t\n\t\t\t_renderData.objects.length = 0;\n\t\t\t_renderData.lights.length = 0;\n\t\n\t\t\tscene.traverseVisible( function ( object ) {\n\t\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\t\n\t\t\t\t\t_renderData.lights.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\tif ( object.material.visible === false ) return;\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\t\n\t\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t\t_object.id = object.id;\n\t\t\t\t\t\t_object.object = object;\n\t\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\t\n\t\t\t\t\t\t_renderData.objects.push( _object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t\tif ( sortObjects === true ) {\n\t\n\t\t\t\t_renderData.objects.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\t\n\t\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\trenderList.setObject( object );\n\t\n\t\t\t\t_modelMatrix = object.matrixWorld;\n\t\n\t\t\t\t_vertexCount = 0;\n\t\n\t\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar offsets = geometry.offsets;\n\t\n\t\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\t\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\t\n\t\t\t\t\t\t\tif ( offsets.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var o = 0; o < offsets.length; o ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar offset = offsets[ o ];\n\t\t\t\t\t\t\t\t\tvar index = offset.index;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\n\t\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\t\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\t\n\t\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ v ];\n\t\n\t\t\t\t\t\t\t_vector3.copy( vertex );\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\t\n\t\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\n\t\t\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t\t : object.material;\n\t\n\t\t\t\t\t\t\tif ( material === undefined ) continue;\n\t\n\t\t\t\t\t\t\tvar side = material.side;\n\t\n\t\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\t\n\t\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\t\n\t\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\t\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\t\n\t\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\t\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t_face.normalModel.negate();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\t\n\t\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalModel.negate();\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\t\n\t\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\t\n\t\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t\t_face.material = material;\n\t\n\t\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\n\t\t\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Line ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\t\t\tif ( attributes.position !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\t\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\n\t\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\t\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\t\n\t\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\t\n\t\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\t\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\t\n\t\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\t\n\t\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\t\n\t\t\t\t\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\t\n\t\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\t\n\t\t\t\t\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\t\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\t\tvar invW = 1 / _vector4.w;\n\t\n\t\t\t\t\t_vector4.z *= invW;\n\t\n\t\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\t\n\t\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t\t_sprite.object = object;\n\t\n\t\t\t\t\t\t_sprite.rotation = object.rotation;\n\t\n\t\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\t\n\t\t\t\t\t\t_sprite.material = object.material;\n\t\n\t\t\t\t\t\t_renderData.elements.push( _sprite );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( sortElements === true ) {\n\t\n\t\t\t\t_renderData.elements.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\treturn _renderData;\n\t\n\t\t};\n\t\n\t\t// Pools\n\t\n\t\tfunction getNextObjectInPool() {\n\t\n\t\t\tif ( _objectCount === _objectPoolLength ) {\n\t\n\t\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t\t_objectPool.push( object );\n\t\t\t\t_objectPoolLength ++;\n\t\t\t\t_objectCount ++;\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t\treturn _objectPool[ _objectCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextVertexInPool() {\n\t\n\t\t\tif ( _vertexCount === _vertexPoolLength ) {\n\t\n\t\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t\t_vertexPool.push( vertex );\n\t\t\t\t_vertexPoolLength ++;\n\t\t\t\t_vertexCount ++;\n\t\t\t\treturn vertex;\n\t\n\t\t\t}\n\t\n\t\t\treturn _vertexPool[ _vertexCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextFaceInPool() {\n\t\n\t\t\tif ( _faceCount === _facePoolLength ) {\n\t\n\t\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t\t_facePool.push( face );\n\t\t\t\t_facePoolLength ++;\n\t\t\t\t_faceCount ++;\n\t\t\t\treturn face;\n\t\n\t\t\t}\n\t\n\t\t\treturn _facePool[ _faceCount ++ ];\n\t\n\t\n\t\t}\n\t\n\t\tfunction getNextLineInPool() {\n\t\n\t\t\tif ( _lineCount === _linePoolLength ) {\n\t\n\t\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t\t_linePool.push( line );\n\t\t\t\t_linePoolLength ++;\n\t\t\t\t_lineCount ++\n\t\t\t\treturn line;\n\t\n\t\t\t}\n\t\n\t\t\treturn _linePool[ _lineCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextSpriteInPool() {\n\t\n\t\t\tif ( _spriteCount === _spritePoolLength ) {\n\t\n\t\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t\t_spritePool.push( sprite );\n\t\t\t\t_spritePoolLength ++;\n\t\t\t\t_spriteCount ++\n\t\t\t\treturn sprite;\n\t\n\t\t\t}\n\t\n\t\t\treturn _spritePool[ _spriteCount ++ ];\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction painterSort( a, b ) {\n\t\n\t\t\tif ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else if ( a.id !== b.id ) {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction clipLine( s1, s2 ) {\n\t\n\t\t\tvar alpha1 = 0, alpha2 = 1,\n\t\n\t\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t\t// Z = -1 and Z = +1, respectively.\n\t\t\tbc1near =  s1.z + s1.w,\n\t\t\tbc2near =  s2.z + s2.w,\n\t\t\tbc1far =  - s1.z + s1.w,\n\t\t\tbc2far =  - s2.z + s2.w;\n\t\n\t\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\t\n\t\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\t\treturn true;\n\t\n\t\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\t\n\t\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\t\treturn false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// The line segment spans at least one clip plane.\n\t\n\t\t\t\tif ( bc1near < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t} else if ( bc2near < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( bc1far < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t} else if ( bc2far < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( alpha2 < alpha1 ) {\n\t\n\t\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\n\n/***/ }\n\n/******/ });\n\n\n/** WEBPACK FOOTER **\n ** Editor.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a77038209ac687b469b6\n **/","define (require) ->\n  THREE = window.THREE\n  TweenTimeEditor = require 'TweenTime.Editor'\n  require 'vendors/three.js-extras/Projector'\n\n  d3 = require 'd3'\n\n  window.EditorUI = class EditorUI\n    constructor: () ->\n      @tweenTime = window.tweenTime\n      @editor = new TweenTimeEditor(@tweenTime, {\n        #onMenuCreated: @onMenuCreated,\n        json_replacer: (key, val) ->\n          # filter some circular values\n          if key == 'container' then return undefined\n          if key == 'parent' then return undefined\n          if key == 'children' then return undefined\n          if key == 'object' then return undefined\n          if key == 'classObject' then return undefined\n          return val\n      })\n      @onMenuCreated($('.timeline__menu'))\n\n      $container = $(window.app.containerWebgl)\n      offset = new THREE.Vector3()\n      projector = new THREE.Projector()\n      mouse = new THREE.Vector2()\n      selectedObject = false\n      selectedObjectPos = new THREE.Vector3()\n\n      plane = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry( 3000, 2000, 8, 8 ),\n        new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.25, transparent: true } )\n      )\n      plane.visible = false\n      #window.app.scene.add( plane )\n\n      getRaycaster = () =>\n        camera = window.activeCamera\n        vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera )\n        raycaster = new THREE.Raycaster(camera.position, vector.sub( camera.position ).normalize())\n        return raycaster\n\n      $container.mousedown (e) =>\n        e.preventDefault()\n        raycaster = getRaycaster()\n        intersects = raycaster.intersectObjects( window.app.scene.children )\n\n        if intersects.length\n          element = intersects[0].object\n          if element._data\n            @editor.selectionManager.select(element._data)\n            selectedObject = element\n            selectedObjectPos = selectedObject.position.clone()\n\n            intersects = raycaster.intersectObject(plane)\n            offset.copy(intersects[ 0 ].point).sub(plane.position)\n      $(window).mouseup (e) =>\n        selectedObject = false\n\n      $container.mousemove (e) =>\n        mouse.x = ( e.clientX / $container.width() ) * 2 - 1\n        mouse.y = -( e.clientY / $container.height() ) * 2 + 1\n\n        if !selectedObject then return\n        if !selectedObject._data then return\n        prop_x = @tweenTime.getProperty('x', selectedObject._data)\n        prop_y = @tweenTime.getProperty('y', selectedObject._data)\n\n        raycaster = getRaycaster()\n        intersects = raycaster.intersectObject( plane )\n        pos = intersects[ 0 ].point.sub( offset )\n\n        posDiff = selectedObjectPos.clone().add(pos)\n\n        @tweenTime.setValue(prop_x, posDiff.x)\n        @tweenTime.setValue(prop_y, posDiff.y)\n        selectedObject._data._isDirty = true\n        @editor.timeline._isDirty = true\n\n\n    onMenuCreated: ($el) =>\n      $el.append('<a class=\"menu-item menu-item--remove\">Remove</a>')\n      $el.prepend('<span class=\"menu-item\">Add<div class=\"submenu submenu--add\"></div></span>')\n\n      @initAdd($el)\n      @initRemove($el)\n\n    initRemove: ($el) =>\n      self = this\n      selectionManager = self.editor.selectionManager\n      data = window.tweenTime.data\n      $el.find('.menu-item--remove').click (e) ->\n        e.preventDefault()\n        for item in selectionManager.selection\n          # only remove full objects.\n          datum = d3.select(item).datum()\n          index = data.indexOf(datum)\n          if datum && datum.type && datum.id && index > -1\n            data.splice(index, 1)\n            # also remove the three.js object\n            if datum.object\n              datum.object.destroy()\n              delete datum.object\n\n        selectionManager.reset()\n        self.editor.render(false, false, true)\n        return\n      return\n\n    initAdd: ($el) =>\n      if !window.ElementFactory then return\n      $container = $el.find('.submenu--add')\n      elements = window.ElementFactory.elements\n      self = this\n\n      for element_name, element of elements\n        $link = $('<a href=\"#\" data-key=\"' + element_name + '\">' + element_name + '</a>')\n        $container.append($link)\n\n      $container.find('a').click (e) ->\n        e.preventDefault()\n        element_name = $(this).data('key')\n        if ElementFactory.elements[element_name]\n          all_data = self.tweenTime.data\n          next_id = all_data.length + 1\n          id = \"item\" + next_id\n          label = element_name + \" \" + next_id\n          current_time = self.tweenTime.timer.time[0] / 1000\n          data =\n            isDirty: true\n            id: id\n            label: label\n            type: element_name\n            start: current_time\n            end: current_time + 2\n            collapsed: false\n            #properties: []\n            #options: window.ElementFactory.elements[element_name].default_attributes()\n            #properties: window.ElementFactory.elements[element_name].default_properties(current_time)\n            properties: ElementFactory.getTypeProperties(element_name)\n\n          self.tweenTime.data.push(data)\n          self.editor.timeline._isDirty = true\n        return\n      return\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/scripts/app/EditorUI.coffee\n **/","module.exports = TweenTime.Editor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"TweenTime.Editor\"\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = d3;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableFace = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.normalModel = new THREE.Vector3();\n\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = new THREE.Color();\n\tthis.material = null;\n\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n//\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\t//\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n\t//\n\n\tvar RenderList = function () {\n\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar object = null;\n\t\tvar material = null;\n\n\t\tvar normalMatrix = new THREE.Matrix3();\n\n\t\tvar setObject = function ( value ) {\n\n\t\t\tobject = value;\n\t\t\tmaterial = object.material;\n\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\n\t\t\tnormals.length = 0;\n\t\t\tuvs.length = 0;\n\n\t\t};\n\n\t\tvar projectVertex = function ( vertex ) {\n\n\t\t\tvar position = vertex.position;\n\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\tvar positionScreen = vertex.positionScreen;\n\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / positionScreen.w;\n\n\t\t\tpositionScreen.x *= invW;\n\t\t\tpositionScreen.y *= invW;\n\t\t\tpositionScreen.z *= invW;\n\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\n\t\t};\n\n\t\tvar pushVertex = function ( x, y, z ) {\n\n\t\t\t_vertex = getNextVertexInPool();\n\t\t\t_vertex.position.set( x, y, z );\n\n\t\t\tprojectVertex( _vertex );\n\n\t\t};\n\n\t\tvar pushNormal = function ( x, y, z ) {\n\n\t\t\tnormals.push( x, y, z );\n\n\t\t};\n\n\t\tvar pushUv = function ( x, y ) {\n\n\t\t\tuvs.push( x, y );\n\n\t\t};\n\n\t\tvar checkTriangleVisibility = function ( v1, v2, v3 ) {\n\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\n\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\treturn _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) );\n\n\t\t};\n\n\t\tvar checkBackfaceCulling = function ( v1, v2, v3 ) {\n\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t};\n\n\t\tvar pushLine = function ( a, b ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\n\t\t\t_line = getNextLineInPool();\n\n\t\t\t_line.id = object.id;\n\t\t\t_line.v1.copy( v1 );\n\t\t\t_line.v2.copy( v2 );\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\n\t\t\t_line.material = object.material;\n\n\t\t\t_renderData.elements.push( _line );\n\n\t\t};\n\n\t\tvar pushTriangle = function ( a, b, c ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\tvar v3 = _vertexPool[ c ];\n\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\n\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\n\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t_face.id = object.id;\n\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tvar offset = arguments[ i ] * 3;\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\n\t\t\t\t\tnormal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\tvar offset2 = arguments[ i ] * 2;\n\n\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\tuv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\t_face.vertexNormalsLength = 3;\n\n\t\t\t\t_face.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t}\n\n\t\t};\n\n\t\treturn {\n\t\t\tsetObject: setObject,\n\t\t\tprojectVertex: projectVertex,\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\tpushVertex: pushVertex,\n\t\t\tpushNormal: pushNormal,\n\t\t\tpushUv: pushUv,\n\t\t\tpushLine: pushLine,\n\t\t\tpushTriangle: pushTriangle\n\t\t}\n\n\t};\n\n\tvar renderList = new RenderList();\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\t_faceCount = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t//\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\n\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.id = object.id;\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\tvar geometry = object.geometry;\n\n\t\t\trenderList.setObject( object );\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\n\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.index !== undefined ) {\n\n\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\tif ( offsets.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( var o = 0; o < offsets.length; o ++ ) {\n\n\t\t\t\t\t\t\t\tvar offset = offsets[ o ];\n\t\t\t\t\t\t\t\tvar index = offset.index;\n\n\t\t\t\t\t\t\t\tfor ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ v ];\n\n\t\t\t\t\t\t_vector3.copy( vertex );\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\n\t\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t : object.material;\n\n\t\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\n\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\n\t\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\tif ( attributes.position !== undefined ) {\n\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\t\tvar vertices = object.geometry.vertices;\n\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t\t_vector4.z *= invW;\n\n\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\n\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t_sprite.object = object;\n\n\t\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\n\t\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) {\n\n\t\t\t_renderData.elements.sort( painterSort );\n\n\t\t}\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFaceInPool() {\n\n\t\tif ( _faceCount === _facePoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t_facePool.push( face );\n\t\t\t_facePoolLength ++;\n\t\t\t_faceCount ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _facePool[ _faceCount ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/scripts/vendors/three.js-extras/Projector.js\n ** module id = 15\n ** module chunks = 0\n **/"],"sourceRoot":""}