{"version":3,"sources":["webpack:///Editor.js","webpack:///webpack/bootstrap 4c3f4d10151ba0a0c039","webpack:///./src/scripts/app/EditorUI.coffee","webpack:///external \"TweenTime.Editor\"","webpack:///external \"d3\"","webpack:///./src/scripts/vendors/three.js-extras/Projector.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","bind","fn","me","apply","arguments","require","EditorUI","THREE","TweenTimeEditor","d3","window","this","initAdd","initRemove","onMenuCreated","$container","getRaycaster","mouse","offset","plane","projector","selectedObject","selectedObjectPos","tweenTime","editor","json_replacer","key","val","$","app","containerWebgl","Vector3","Projector","Vector2","Mesh","PlaneBufferGeometry","MeshBasicMaterial","color","opacity","transparent","visible","onSelect","add","item","addToSelection","dispatchEvent","Event","_this","camera","raycaster","vector","activeCamera","x","y","unproject","Raycaster","position","sub","normalize","mousedown","e","element","intersects","preventDefault","intersectObjects","scene","children","length","object","_data","selectionManager","select","clone","intersectObject","copy","point","mouseup","mousemove","pos","posDiff","prop_x","prop_y","clientX","width","clientY","height","getProperty","setValue","_isDirty","timeline","prototype","$el","append","prepend","data","self","find","click","datum","i","index","len","ref","selection","indexOf","type","splice","destroy","reset","render","$link","element_name","elements","ElementFactory","all_data","current_time","label","next_id","timer","time","isDirty","start","end","collapsed","properties","getTypeProperties","push","undefined",4,"TweenTime","Editor",5,14,"RenderableObject","z","RenderableFace","v1","RenderableVertex","v2","v3","normalModel","vertexNormalsModel","vertexNormalsLength","Color","material","uvs","positionWorld","positionScreen","Vector4","vertex","RenderableLine","vertexColors","RenderableSprite","rotation","scale","getNextObjectInPool","_objectCount","_objectPoolLength","_objectPool","getNextVertexInPool","_vertexCount","_vertexPoolLength","_vertexPool","getNextFaceInPool","_faceCount","_facePoolLength","face","_facePool","getNextLineInPool","_lineCount","_linePoolLength","line","_linePool","getNextSpriteInPool","_spriteCount","_spritePoolLength","sprite","_spritePool","painterSort","a","b","clipLine","s1","s2","alpha1","alpha2","bc1near","w","bc2near","bc1far","bc2far","Math","max","min","lerp","_object","_vertex","_face","_line","_sprite","_modelMatrix","_renderData","objects","lights","_vector3","_vector4","_clipBox","Box3","_boundingBox","_points3","Array","_viewMatrix","Matrix4","_viewProjectionMatrix","_modelViewProjectionMatrix","_normalMatrix","Matrix3","_frustum","Frustum","_clippedVertex1PositionScreen","_clippedVertex2PositionScreen","projectVector","console","warn","project","unprojectVector","pickingRay","error","RenderList","normals","normalMatrix","setObject","value","getNormalMatrix","matrixWorld","projectVertex","applyMatrix4","invW","pushVertex","set","pushNormal","pushUv","checkTriangleVisibility","isIntersectionBox","setFromPoints","checkBackfaceCulling","pushLine","pushTriangle","side","DoubleSide","normal","applyMatrix3","offset2","uv","renderList","projectScene","sortObjects","sortElements","autoUpdate","updateMatrixWorld","parent","matrixWorldInverse","getInverse","multiplyMatrices","projectionMatrix","setFromMatrix","traverseVisible","Light","Line","Sprite","frustumCulled","intersectsObject","setFromMatrixPosition","applyProjection","sort","o","ol","geometry","BufferGeometry","attributes","offsets","positions","array","l","indices","count","Geometry","vertices","faces","faceVertexUvs","isFaceMaterial","MeshFaceMaterial","objectMaterials","v","vl","morphTargets","morphInfluences","morphTargetInfluences","t","tl","influence","target","targetVertex","f","fl","materials","materialIndex","FrontSide","BackSide","negate","faceVertexNormals","vertexNormals","n","nl","vertexUvs","u","step","mode","LinePieces","multiplyScalar","VertexColors","colors","abs"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,UAGAV,EAAA,KDMM,EACA,SAASI,EAAQD,EAASH,GE7ChC,GAAAW,GAAAC,EAAA,SAAAC,EAAAC,GAAA,wBAAAD,GAAAE,MAAAD,EAAAE,YAAAL,GAAO,SAACM,GACN,GAAAC,GAAAC,EAAAC,EAAAC,CFsDC,OEtDDF,GAAQG,OAAOH,MACfC,EAAkBpB,EAAQ,GAC1BA,EAAQ,IAERqB,EAAKrB,EAAQ,GAEbsB,OAAOJ,SAAiBA,EAAA,WACT,QAAAA,KACXK,KAAAC,QAAAZ,EAAAW,KAAAC,QAAAD,WAAAE,WAAAb,EAAAW,KAAAE,WAAAF,WAAAG,cAAAd,EAAAW,KAAAG,cAAAH,KAAA,IAAAI,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,CAAAX,MAACY,UAAYb,OAAOa,UACpBZ,KAACa,OAAa,GAAAhB,GAAgBG,KAACY,WAE7BE,cAAe,SAACC,EAAKC,GAEnB,MAAU,cAAPD,EAA+B,OACxB,WAAPA,EAA4B,OACrB,aAAPA,EAA8B,OACvB,WAAPA,EAA4B,OACrB,gBAAPA,EAAiC,OAC7BC,KAEXhB,KAACG,cAAcc,EAAE,oBAEjBb,EAAaa,EAAElB,OAAOmB,IAAIC,gBAC1BZ,EAAa,GAAAX,GAAMwB,QACnBX,EAAgB,GAAAb,GAAMyB,UACtBf,EAAY,GAAAV,GAAM0B,QAClBZ,GAAiB,EACjBC,EAAwB,GAAAf,GAAMwB,QAE9BZ,EAAY,GAAAZ,GAAM2B,KACZ,GAAA3B,GAAM4B,oBAAqB,IAAM,IAAM,EAAG,GAC1C,GAAA5B,GAAM6B,mBAAqBC,MAAO,SAAUC,QAAS,IAAMC,aAAa,KAE9EpB,EAAMqB,SAAU,EAGhB7B,KAACa,OAAOiB,SAASC,IAAI,SAACC,EAAMC,GF2DzB,MEzDDlC,QAAOmC,cAAkB,GAAAC,OAAM,aAGjC9B,EAAe,SAAA+B,GFyDZ,MEzDY,YACb,GAAAC,GAAAC,EAAAC,CAGA,OAHAF,GAAStC,OAAOyC,aAChBD,EAAa,GAAA3C,GAAMwB,QAASd,EAAMmC,EAAGnC,EAAMoC,EAAG,IAAMC,UAAWN,GAC/DC,EAAgB,GAAA1C,GAAMgD,UAAUP,EAAOQ,SAAUN,EAAOO,IAAKT,EAAOQ,UAAWE,eAHlE/C,MAMfI,EAAW4C,UAAU,SAAAZ,GF4DlB,ME5DkB,UAACa,GACpB,GAAAC,GAAAC,EAAAb,CAIA,OAJAW,GAAEG,iBACFd,EAAYjC,IACZ8C,EAAab,EAAUe,iBAAkBtD,OAAOmB,IAAIoC,MAAMC,UAEvDJ,EAAWK,SACZN,EAAUC,EAAW,GAAGM,OACrBP,EAAQQ,QACTtB,EAACvB,OAAO8C,iBAAiBC,OAAOV,EAAQQ,OACxChD,EAAiBwC,EACjBvC,EAAoBD,EAAemC,SAASgB,QAE5CV,EAAab,EAAUwB,gBAAgBtD,GACvCD,EAAOwD,KAAKZ,EAAY,GAAIa,OAAOlB,IAAItC,EAAMqC,WARjD,SALmB7C,OAcrBiB,EAAElB,QAAQkE,QAAQ,SAAA7B,GFgEf,MEhEe,UAACa,GFiEd,MEhEHvC,IAAiB,IADDV,OAGlBI,EAAW8D,UAAU,SAAA9B,GFkElB,MElEkB,UAACa,GACpB,GAAAE,GAAAgB,EAAAC,EAAAC,EAAAC,EAAAhC,CAGA,OAHAhC,GAAMmC,EAAMQ,EAAEsB,QAAUnE,EAAWoE,QAAY,EAAI,EACnDlE,EAAMoC,EAA2C,IAApCO,EAAEwB,QAAUrE,EAAWsE,UAAiB,EAElDhE,GACAA,EAAgBgD,OACnBW,EAASjC,EAACxB,UAAU+D,YAAY,IAAKjE,EAAegD,OACpDY,EAASlC,EAACxB,UAAU+D,YAAY,IAAKjE,EAAegD,OAEpDpB,EAAYjC,IACZ8C,EAAab,EAAUwB,gBAAiBtD,GACxC2D,EAAMhB,EAAY,GAAIa,MAAMlB,IAAKvC,GAEjC6D,EAAUzD,EAAkBkD,QAAQ9B,IAAIoC,GAExC/B,EAACxB,UAAUgE,SAASP,EAAQD,EAAQ3B,GACpCL,EAACxB,UAAUgE,SAASN,EAAQF,EAAQ1B,GACpChC,EAAegD,MAAMmB,UAAW,EAChCzC,EAACvB,OAAOiE,SAASD,UAAW,GAd5B,SAJmB7E,OFkKtB,ME3NDL,GAAAoF,UA8EA5E,cAAe,SAAC6E,GFyEb,MExEDA,GAAIC,OAAO,qDACXD,EAAIE,QAAQ,8EAEZlF,KAACC,QAAQ+E,GACThF,KAACE,WAAW8E,IAnFdrF,EAAAoF,UAqFA7E,WAAY,SAAC8E,GACX,GAAAG,GAAAxB,EAAAyB,IAAOpF,KACP2D,EAAmByB,EAAKvE,OAAO8C,iBAC/BwB,EAAOpF,OAAOa,UAAUuE,KACxBH,EAAIK,KAAK,sBAAsBC,MAAM,SAACrC,GACpC,GAAAsC,GAAAC,EAAAC,EAAAzD,EAAA0D,EAAAC,CACA,KADA1C,EAAEG,iBACFuC,EAAAhC,EAAAiC,UAAAJ,EAAA,EAAAE,EAAAC,EAAAnC,OAAAkC,EAAAF,MFyEGxD,EAAO2D,EAAIH,GEvEZD,EAAQzF,EAAG8D,OAAO5B,GAAMuD,QACxBE,EAAQN,EAAKU,QAAQN,GAClBA,GAASA,EAAMO,MAAQP,EAAMzG,IAAM2G,EAAQ,KAC5CN,EAAKY,OAAON,EAAO,GAEhBF,EAAM9B,SACP8B,EAAM9B,OAAOuC,gBACbT,GAAa9B,QAEnBE,GAAiBsC,QACjBb,EAAKvE,OAAOqF,QAAO,GAAO,GAAO,MAvGrCvG,EAAAoF,UA2GA9E,QAAS,SAAC+E,GACR,GAAA5E,GAAA+F,EAAAjD,EAAAkD,EAAAC,EAAAjB,CAAA,IAAGrF,OAAQuG,eAAX,CACAlG,EAAa4E,EAAIK,KAAK,iBACtBgB,EAAWtG,OAAOuG,eAAeD,SACjCjB,EAAOpF,IAEP,KAAAoG,IAAAC,GF4EGnD,EAAUmD,EAASD,GE3EpBD,EAAQlF,EAAE,yBAA2BmF,EAAe,KAAOA,EAAe,QAC1EhG,EAAW6E,OAAOkB,EAEpB/F,GAAWiF,KAAK,KAAKC,MAAM,SAACrC,GAC1B,GAAAsD,GAAAC,EAAArB,EAAArG,EAAA2H,EAAAC,CAAAzD,GAAEG,iBACFgD,EAAenF,EAAEjB,MAAMmF,KAAK,OACzBmB,eAAeD,SAASD,KACzBG,EAAWnB,EAAKxE,UAAUuE,KAC1BuB,EAAUH,EAAS/C,OAAS,EAC5B1E,EAAK,OAAS4H,EACdD,EAAQL,EAAe,IAAMM,EAC7BF,EAAepB,EAAKxE,UAAU+F,MAAMC,KAAK,GAAK,IAC9CzB,GACE0B,SAAS,EACT/H,GAAIA,EACJ2H,MAAOA,EACPX,KAAMM,EACNU,MAAON,EACPO,IAAKP,EAAe,EACpBQ,WAAW,EAIXC,WAAYX,eAAeY,kBAAkBd,IAE/ChB,EAAKxE,UAAUuE,KAAKgC,KAAKhC,GACzBC,EAAKvE,OAAOiE,SAASD,UAAW,OF+E9BlF,MEnOZX,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAuI,SAAAhI,IAAAP,EAAAD,QAAAQ,KF2OMiI,EACA,SAASxI,EAAQD,EAASH,GG5OhCI,EAAAD,QAAA0I,UAAAC,QHkPMC,EACA,SAAS3I,EAAQD,EAASH,GInPhCI,EAAAD,QAAAkB,IJyPM2H,GACA,SAAS5I,EAAQD,EAASH,GKpPhCmB,MAAA8H,iBAAA,WAEA1H,KAAAlB,GAAA,EAEAkB,KAAAyD,OAAA,KACAzD,KAAA2H,EAAA,GAMA/H,MAAAgI,eAAA,WAEA5H,KAAAlB,GAAA,EAEAkB,KAAA6H,GAAA,GAAAjI,OAAAkI,iBACA9H,KAAA+H,GAAA,GAAAnI,OAAAkI,iBACA9H,KAAAgI,GAAA,GAAApI,OAAAkI,iBAEA9H,KAAAiI,YAAA,GAAArI,OAAAwB,QAEApB,KAAAkI,oBAAA,GAAAtI,OAAAwB,QAAA,GAAAxB,OAAAwB,QAAA,GAAAxB,OAAAwB,SACApB,KAAAmI,oBAAA,EAEAnI,KAAA0B,MAAA,GAAA9B,OAAAwI,MACApI,KAAAqI,SAAA,KACArI,KAAAsI,KAAA,GAAA1I,OAAA0B,QAAA,GAAA1B,OAAA0B,QAAA,GAAA1B,OAAA0B,SAEAtB,KAAA2H,EAAA,GAMA/H,MAAAkI,iBAAA,WAEA9H,KAAA6C,SAAA,GAAAjD,OAAAwB,QACApB,KAAAuI,cAAA,GAAA3I,OAAAwB,QACApB,KAAAwI,eAAA,GAAA5I,OAAA6I,QAEAzI,KAAA6B,SAAA,GAIAjC,MAAAkI,iBAAA/C,UAAAhB,KAAA,SAAA2E,GAEA1I,KAAAuI,cAAAxE,KAAA2E,EAAAH,eACAvI,KAAAwI,eAAAzE,KAAA2E,EAAAF,iBAMA5I,MAAA+I,eAAA,WAEA3I,KAAAlB,GAAA,EAEAkB,KAAA6H,GAAA,GAAAjI,OAAAkI,iBACA9H,KAAA+H,GAAA,GAAAnI,OAAAkI,iBAEA9H,KAAA4I,cAAA,GAAAhJ,OAAAwI,MAAA,GAAAxI,OAAAwI,OACApI,KAAAqI,SAAA,KAEArI,KAAA2H,EAAA,GAMA/H,MAAAiJ,iBAAA,WAEA7I,KAAAlB,GAAA,EAEAkB,KAAAyD,OAAA,KAEAzD,KAAAyC,EAAA,EACAzC,KAAA0C,EAAA,EACA1C,KAAA2H,EAAA,EAEA3H,KAAA8I,SAAA,EACA9I,KAAA+I,MAAA,GAAAnJ,OAAA0B,QAEAtB,KAAAqI,SAAA,MAMAzI,MAAAyB,UAAA,WA8nBA,QAAA2H,KAEA,GAAAC,IAAAC,EAAA,CAEA,GAAAzF,GAAA,GAAA7D,OAAA8H,gBAIA,OAHAyB,GAAAhC,KAAA1D,GACAyF,IACAD,IACAxF,EAIA,MAAA0F,GAAAF,KAIA,QAAAG,KAEA,GAAAC,IAAAC,EAAA,CAEA,GAAAZ,GAAA,GAAA9I,OAAAkI,gBAIA,OAHAyB,GAAApC,KAAAuB,GACAY,IACAD,IACAX,EAIA,MAAAa,GAAAF,KAIA,QAAAG,KAEA,GAAAC,IAAAC,EAAA,CAEA,GAAAC,GAAA,GAAA/J,OAAAgI,cAIA,OAHAgC,GAAAzC,KAAAwC,GACAD,IACAD,IACAE,EAIA,MAAAC,GAAAH,KAKA,QAAAI,KAEA,GAAAC,IAAAC,EAAA,CAEA,GAAAC,GAAA,GAAApK,OAAA+I,cAIA,OAHAsB,GAAA9C,KAAA6C,GACAD,IACAD,IACAE,EAIA,MAAAC,GAAAH,KAIA,QAAAI,KAEA,GAAAC,IAAAC,EAAA,CAEA,GAAAC,GAAA,GAAAzK,OAAAiJ,gBAIA,OAHAyB,GAAAnD,KAAAkD,GACAD,IACAD,IACAE,EAIA,MAAAC,GAAAH,KAMA,QAAAI,GAAAC,EAAAC,GAEA,MAAAD,GAAA7C,IAAA8C,EAAA9C,EAEA8C,EAAA9C,EAAA6C,EAAA7C,EAEG6C,EAAA1L,KAAA2L,EAAA3L,GAEH0L,EAAA1L,GAAA2L,EAAA3L,GAIA,EAMA,QAAA4L,GAAAC,EAAAC,GAEA,GAAAC,GAAA,EAAAC,EAAA,EAIAC,EAAAJ,EAAAhD,EAAAgD,EAAAK,EACAC,EAAAL,EAAAjD,EAAAiD,EAAAI,EACAE,GAAAP,EAAAhD,EAAAgD,EAAAK,EACAG,GAAAP,EAAAjD,EAAAiD,EAAAI,CAEA,OAAAD,IAAA,GAAAE,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAGA,EAEG,EAAAJ,GAAA,EAAAE,GAAA,EAAAC,GAAA,EAAAC,GAGH,GAMA,EAAAJ,EAGAF,EAAAO,KAAAC,IAAAR,EAAAE,KAAAE,IAEI,EAAAA,IAGJH,EAAAM,KAAAE,IAAAR,EAAAC,KAAAE,KAIA,EAAAC,EAGAL,EAAAO,KAAAC,IAAAR,EAAAK,KAAAC,IAEI,EAAAA,IAGJL,EAAAM,KAAAE,IAAAR,EAAAI,KAAAC,KAIAN,EAAAC,GAKA,GAKAH,EAAAY,KAAAX,EAAAC,GACAD,EAAAW,KAAAZ,EAAA,EAAAG,IAEA,IA/xBA,GAAAU,GAAAvC,EACAwC,EAAApC,EACAqC,EAAAjC,EACAkC,EAAA7B,EACA8B,EAAAzB,EAeA0B,EAnBA1C,KAAAD,EAAA,EACAK,KAAAD,EAAA,EACAM,KAAAF,EAAA,EACAO,KAAAF,EAAA,EACAO,KAAAF,EAAA,EAEA0B,GAAgBC,WAAAC,UAAA3F,aAEhB4F,EAAA,GAAArM,OAAAwB,QACA8K,EAAA,GAAAtM,OAAA6I,QAEA0D,EAAA,GAAAvM,OAAAwM,KAAA,GAAAxM,OAAAwB,QAAA,aAAAxB,OAAAwB,QAAA,QACAiL,EAAA,GAAAzM,OAAAwM,KACAE,EAAA,GAAAC,OAAA,GAGAC,GAFA,GAAAD,OAAA,GAEA,GAAA3M,OAAA6M,SACAC,EAAA,GAAA9M,OAAA6M,QAGAE,EAAA,GAAA/M,OAAA6M,QAEAG,EAAA,GAAAhN,OAAAiN,QAEAC,EAAA,GAAAlN,OAAAmN,QAEAC,EAAA,GAAApN,OAAA6I,QACAwE,EAAA,GAAArN,OAAA6I,OAIAzI,MAAAkN,cAAA,SAAA3K,EAAAF,GAEA8K,QAAAC,KAAA,8DACA7K,EAAA8K,QAAAhL,IAIArC,KAAAsN,gBAAA,SAAA/K,EAAAF,GAEA8K,QAAAC,KAAA,kEACA7K,EAAAI,UAAAN,IAIArC,KAAAuN,WAAA,SAAAhL,EAAAF,GAEA8K,QAAAK,MAAA,oEAMA,IAAAC,GAAA,WAEA,GAAAC,MACApF,KAEA7E,EAAA,KACA4E,EAAA,KAEAsF,EAAA,GAAA/N,OAAAiN,QAEAe,EAAA,SAAAC,GAEApK,EAAAoK,EACAxF,EAAA5E,EAAA4E,SAEAsF,EAAAG,gBAAArK,EAAAsK,aAEAL,EAAAlK,OAAA,EACA8E,EAAA9E,OAAA,GAIAwK,EAAA,SAAAtF,GAEA,GAAA7F,GAAA6F,EAAA7F,SACA0F,EAAAG,EAAAH,cACAC,EAAAE,EAAAF,cAEAD,GAAAxE,KAAAlB,GAAAoL,aAAApC,GACArD,EAAAzE,KAAAwE,GAAA0F,aAAAvB,EAEA,IAAAwB,GAAA,EAAA1F,EAAAwC,CAEAxC,GAAA/F,GAAAyL,EACA1F,EAAA9F,GAAAwL,EACA1F,EAAAb,GAAAuG,EAEAxF,EAAA7G,QAAA2G,EAAA/F,GAAA,IAAA+F,EAAA/F,GAAA,GACA+F,EAAA9F,GAAA,IAAA8F,EAAA9F,GAAA,GACA8F,EAAAb,GAAA,IAAAa,EAAAb,GAAA,GAIAwG,EAAA,SAAA1L,EAAAC,EAAAiF,GAEA8D,EAAArC,IACAqC,EAAA5I,SAAAuL,IAAA3L,EAAAC,EAAAiF,GAEAqG,EAAAvC,IAIA4C,EAAA,SAAA5L,EAAAC,EAAAiF,GAEA+F,EAAAvG,KAAA1E,EAAAC,EAAAiF,IAIA2G,EAAA,SAAA7L,EAAAC,GAEA4F,EAAAnB,KAAA1E,EAAAC,IAIA6L,EAAA,SAAA1G,EAAAE,EAAAC,GAEA,MAAAH,GAAAhG,WAAA,GAAAkG,EAAAlG,WAAA,GAAAmG,EAAAnG,WAAA,MAEAyK,EAAA,GAAAzE,EAAAW,eACA8D,EAAA,GAAAvE,EAAAS,eACA8D,EAAA,GAAAtE,EAAAQ,eAEA2D,EAAAqC,kBAAAnC,EAAAoC,cAAAnC,MAIAoC,EAAA,SAAA7G,EAAAE,EAAAC,GAEA,OAAAA,EAAAQ,eAAA/F,EAAAoF,EAAAW,eAAA/F,IACAsF,EAAAS,eAAA9F,EAAAmF,EAAAW,eAAA9F,IACAsF,EAAAQ,eAAA9F,EAAAmF,EAAAW,eAAA9F,IACAqF,EAAAS,eAAA/F,EAAAoF,EAAAW,eAAA/F,GAAA,GAIAkM,EAAA,SAAAnE,EAAAC,GAEA,GAAA5C,GAAA0B,EAAAiB,GACAzC,EAAAwB,EAAAkB,EAEAkB,GAAA9B,IAEA8B,EAAA7M,GAAA2E,EAAA3E,GACA6M,EAAA9D,GAAA9D,KAAA8D,GACA8D,EAAA5D,GAAAhE,KAAAgE,GACA4D,EAAAhE,GAAAE,EAAAW,eAAAb,EAAAI,EAAAS,eAAAb,GAAA,EAEAgE,EAAAtD,SAAA5E,EAAA4E,SAEAyD,EAAAzF,SAAAc,KAAAwE,IAIAiD,EAAA,SAAApE,EAAAC,EAAAvL,GAEA,GAAA2I,GAAA0B,EAAAiB,GACAzC,EAAAwB,EAAAkB,GACAzC,EAAAuB,EAAArK,EAEA,IAAAqP,EAAA1G,EAAAE,EAAAC,MAAA,IAEAK,EAAAwG,OAAAjP,MAAAkP,YAAAJ,EAAA7G,EAAAE,EAAAC,MAAA,IAEA0D,EAAAlC,IAEAkC,EAAA5M,GAAA2E,EAAA3E,GACA4M,EAAA7D,GAAA9D,KAAA8D,GACA6D,EAAA3D,GAAAhE,KAAAgE,GACA2D,EAAA1D,GAAAjE,KAAAiE,GACA0D,EAAA/D,GAAAE,EAAAW,eAAAb,EAAAI,EAAAS,eAAAb,EAAAK,EAAAQ,eAAAb,GAAA,CAEA,QAAAnC,GAAA,EAAoB,EAAAA,EAAOA,IAAA,CAE3B,GAAAjF,GAAA,EAAAd,UAAA+F,GACAuJ,EAAArD,EAAAxD,mBAAA1C,EAEAuJ,GAAAX,IAAAV,EAAAnN,GAAAmN,EAAAnN,EAAA,GAAAmN,EAAAnN,EAAA,IACAwO,EAAAC,aAAArB,GAAA5K,WAEA,IAAAkM,GAAA,EAAAxP,UAAA+F,GAEA0J,EAAAxD,EAAApD,IAAA9C,EACA0J,GAAAd,IAAA9F,EAAA2G,GAAA3G,EAAA2G,EAAA,IAIAvD,EAAAvD,oBAAA,EAEAuD,EAAArD,SAAA5E,EAAA4E,SAEAyD,EAAAzF,SAAAc,KAAAuE,IAMA,QACAkC,YACAI,gBACAO,0BACAG,uBACAP,aACAE,aACAC,SACAK,WACAC,iBAKAO,EAAA,GAAA1B,EAEAzN,MAAAoP,aAAA,SAAA9L,EAAAjB,EAAAgN,EAAAC,GAEA7F,EAAA,EACAK,EAAA,EACAK,EAAA,EAEA2B,EAAAzF,SAAA7C,OAAA,EAEAF,EAAAiM,cAAA,GAAAjM,EAAAkM,oBACApI,SAAA/E,EAAAoN,QAAApN,EAAAmN,oBAEAhD,EAAAzI,KAAA1B,EAAAqN,mBAAAC,WAAAtN,EAAA0L,cACArB,EAAAkD,iBAAAvN,EAAAwN,iBAAArD,GAEAM,EAAAgD,cAAApD,GAIAzD,EAAA,EAEA6C,EAAAC,QAAAvI,OAAA,EACAsI,EAAAE,OAAAxI,OAAA,EAEAF,EAAAyM,gBAAA,SAAAtM,GAEA,GAAAA,YAAA7D,OAAAoQ,MAEAlE,EAAAE,OAAA7E,KAAA1D,OAEI,IAAAA,YAAA7D,OAAA2B,MAAAkC,YAAA7D,OAAAqQ,MAAAxM,YAAA7D,OAAAsQ,OAAA,CAEJ,GAAAzM,EAAA4E,SAAAxG,WAAA,UAEA4B,EAAA0M,iBAAA,GAAArD,EAAAsD,iBAAA3M,MAAA,KAEA+H,EAAAxC,IACAwC,EAAA1M,GAAA2E,EAAA3E,GACA0M,EAAA/H,SAEAwI,EAAAoE,sBAAA5M,EAAAsK,aACA9B,EAAAqE,gBAAA5D,GACAlB,EAAA7D,EAAAsE,EAAAtE,EAEAmE,EAAAC,QAAA5E,KAAAqE,OAQA6D,KAAA,GAEAvD,EAAAC,QAAAwE,KAAAhG,EAMA,QAAAiG,GAAA,EAAAC,EAAA3E,EAAAC,QAAAvI,OAAmDiN,EAAAD,EAAQA,IAAA,CAE3D,GAAA/M,GAAAqI,EAAAC,QAAAyE,GAAA/M,OACAiN,EAAAjN,EAAAiN,QAQA,IANAvB,EAAAvB,UAAAnK,GAEAoI,EAAApI,EAAAsK,YAEA1E,EAAA,EAEA5F,YAAA7D,OAAA2B,MAEA,GAAAmP,YAAA9Q,OAAA+Q,eAAA,CAEA,GAAAC,GAAAF,EAAAE,WACAC,EAAAH,EAAAG,OAEA,IAAAzJ,SAAAwJ,EAAA/N,SAAA,QAIA,QAFAiO,GAAAF,EAAA/N,SAAAkO,MAEAvL,EAAA,EAAAwL,EAAAF,EAAAtN,OAA2CwN,EAAAxL,EAAOA,GAAA,EAElD2J,EAAAhB,WAAA2C,EAAAtL,GAAAsL,EAAAtL,EAAA,GAAAsL,EAAAtL,EAAA,GAIA,IAAA4B,SAAAwJ,EAAA7B,OAIA,OAFArB,GAAAkD,EAAA7B,OAAAgC,MAEAvL,EAAA,EAAAwL,EAAAtD,EAAAlK,OAA0CwN,EAAAxL,EAAOA,GAAA,EAEjD2J,EAAAd,WAAAX,EAAAlI,GAAAkI,EAAAlI,EAAA,GAAAkI,EAAAlI,EAAA,GAMA,IAAA4B,SAAAwJ,EAAA1B,GAIA,OAFA5G,GAAAsI,EAAA1B,GAAA6B,MAEAvL,EAAA,EAAAwL,EAAA1I,EAAA9E,OAAsCwN,EAAAxL,EAAOA,GAAA,EAE7C2J,EAAAb,OAAAhG,EAAA9C,GAAA8C,EAAA9C,EAAA,GAMA,IAAA4B,SAAAwJ,EAAAnL,MAAA,CAEA,GAAAwL,GAAAL,EAAAnL,MAAAsL,KAEA,IAAAF,EAAArN,OAAA,EAEA,OAAAgN,GAAA,EAAuBA,EAAAK,EAAArN,OAAoBgN,IAK3C,OAHAjQ,GAAAsQ,EAAAL,GACA/K,EAAAlF,EAAAkF,MAEAD,EAAAjF,EAAAuG,MAAAkK,EAAAzQ,EAAAuG,MAAAvG,EAAA2Q,MAAoEF,EAAAxL,EAAOA,GAAA,EAE3E2J,EAAAP,aAAAqC,EAAAzL,GAAAC,EAAAwL,EAAAzL,EAAA,GAAAC,EAAAwL,EAAAzL,EAAA,GAAAC,OAQA,QAAAD,GAAA,EAAAwL,EAAAC,EAAAzN,OAA2CwN,EAAAxL,EAAOA,GAAA,EAElD2J,EAAAP,aAAAqC,EAAAzL,GAAAyL,EAAAzL,EAAA,GAAAyL,EAAAzL,EAAA,QAQA,QAAAA,GAAA,EAAAwL,EAAAF,EAAAtN,OAAA,EAAgDwN,EAAAxL,EAAOA,GAAA,EAEvD2J,EAAAP,aAAApJ,IAAA,EAAAA,EAAA,OAMK,IAAAkL,YAAA9Q,OAAAuR,SAAA,CAEL,GAAAC,GAAAV,EAAAU,SACAC,EAAAX,EAAAW,MACAC,EAAAZ,EAAAY,cAAA,EAEA1E,GAAAkB,gBAAAjC,EAOA,QALAxD,GAAA5E,EAAA4E,SAEAkJ,EAAAlJ,YAAAzI,OAAA4R,iBACAC,EAAAF,KAAA,EAAA9N,EAAA4E,SAAA,KAEAqJ,EAAA,EAAAC,GAAAP,EAAA5N,OAA2CmO,GAAAD,EAAQA,IAAA,CAEnD,GAAAhJ,IAAA0I,EAAAM,EAIA,IAFAzF,EAAAlI,KAAA2E,IAEAL,EAAAuJ,gBAAA,EAKA,OAHAA,IAAAlB,EAAAkB,aACAC,GAAApO,EAAAqO,sBAEAC,GAAA,EAAAC,GAAAJ,GAAApO,OAAiDwO,GAAAD,GAAQA,KAAA,CAEzD,GAAAE,IAAAJ,GAAAE,GAEA,QAAAE,GAAA,CAEA,GAAAC,IAAAN,GAAAG,IACAI,GAAAD,GAAAd,SAAAM,EAEAzF,GAAAxJ,IAAA0P,GAAA1P,EAAAiG,GAAAjG,GAAAwP,GACAhG,EAAAvJ,IAAAyP,GAAAzP,EAAAgG,GAAAhG,GAAAuP,GACAhG,EAAAtE,IAAAwK,GAAAxK,EAAAe,GAAAf,GAAAsK,IAMA9C,EAAAhB,WAAAlC,EAAAxJ,EAAAwJ,EAAAvJ,EAAAuJ,EAAAtE,GAIA,OAAAyK,IAAA,EAAAC,GAAAhB,EAAA7N,OAAwC6O,GAAAD,GAAQA,KAAA,CAEhD,GAAAzI,IAAA0H,EAAAe,IAEA/J,EAAAkJ,KAAA,EACAE,EAAAa,UAAA3I,GAAA4I,eACA9O,EAAA4E,QAEA,IAAAjB,SAAAiB,EAAA,CAEA,GAAAwG,IAAAxG,EAAAwG,KAEAhH,GAAA0B,EAAAI,GAAAa,GACAzC,GAAAwB,EAAAI,GAAAc,GACAzC,GAAAuB,EAAAI,GAAAzK,EAEA,IAAAiQ,EAAAZ,wBAAA1G,GAAAE,GAAAC,OAAA,GAEA,GAAAnG,IAAAsN,EAAAT,qBAAA7G,GAAAE,GAAAC,GAEA,IAAA6G,KAAAjP,MAAAkP,WAAA,CACA,GAAAD,KAAAjP,MAAA4S,WAAA3Q,MAAA,UACA,IAAAgN,KAAAjP,MAAA6S,UAAA5Q,MAAA,WAGA6J,EAAAlC,IAEAkC,EAAA5M,GAAA2E,EAAA3E,GACA4M,EAAA7D,GAAA9D,KAAA8D,IACA6D,EAAA3D,GAAAhE,KAAAgE,IACA2D,EAAA1D,GAAAjE,KAAAiE,IAEA0D,EAAAzD,YAAAlE,KAAA4F,GAAAoF,QAEAlN,MAAA,GAAAgN,KAAAjP,MAAA6S,UAAA5D,KAAAjP,MAAAkP,YAEApD,EAAAzD,YAAAyK,SAIAhH,EAAAzD,YAAA+G,aAAApC,GAAA7J,WAIA,QAFA4P,IAAAhJ,GAAAiJ,cAEAC,GAAA,EAAAC,GAAA1H,KAAAE,IAAAqH,GAAAnP,OAAA,GAAoEsP,GAAAD,GAAQA,KAAA,CAE5E,GAAA5K,IAAAyD,EAAAxD,mBAAA2K,GACA5K,IAAAlE,KAAA4O,GAAAE,KAEAhR,MAAA,GAAAgN,KAAAjP,MAAA6S,UAAA5D,KAAAjP,MAAAkP,YAEA7G,GAAAyK,SAIAzK,GAAA+G,aAAApC,GAAA7J,YAIA2I,EAAAvD,oBAAAwK,GAAAnP,MAEA,IAAAuP,IAAAzB,EAAAc,GAEA,IAAAhL,SAAA2L,GAEA,OAAAC,IAAA,EAAuB,EAAAA,GAAOA,KAE9BtH,EAAApD,IAAA0K,IAAAjP,KAAAgP,GAAAC,IAMAtH,GAAAhK,MAAAiI,GAAAjI,MACAgK,EAAArD,WAEAqD,EAAA/D,GAAAE,GAAAW,eAAAb,EAAAI,GAAAS,eAAAb,EAAAK,GAAAQ,eAAAb,GAAA,EAEAmE,EAAAzF,SAAAc,KAAAuE,WAMI,IAAAjI,YAAA7D,OAAAqQ,MAEJ,GAAAS,YAAA9Q,OAAA+Q,eAAA,CAEA,GAAAC,GAAAF,EAAAE,UAEA,IAAAxJ,SAAAwJ,EAAA/N,SAAA,CAIA,OAFAiO,GAAAF,EAAA/N,SAAAkO,MAEAvL,EAAA,EAAAwL,EAAAF,EAAAtN,OAA4CwN,EAAAxL,EAAOA,GAAA,EAEnD2J,EAAAhB,WAAA2C,EAAAtL,GAAAsL,EAAAtL,EAAA,GAAAsL,EAAAtL,EAAA,GAIA,IAAA4B,SAAAwJ,EAAAnL,MAIA,OAFAwL,GAAAL,EAAAnL,MAAAsL,MAEAvL,EAAA,EAAAwL,EAAAC,EAAAzN,OAA2CwN,EAAAxL,EAAOA,GAAA,EAElD2J,EAAAR,SAAAsC,EAAAzL,GAAAyL,EAAAzL,EAAA,QAQA,QAFAyN,IAAAxP,EAAAyP,OAAAtT,MAAAuT,WAAA,IAEA3N,EAAA,EAAAwL,EAAAF,EAAAtN,OAAA,IAAyDwN,EAAAxL,EAAOA,GAAAyN,GAEhE9D,EAAAR,SAAAnJ,IAAA,QAQK,IAAAkL,YAAA9Q,OAAAuR,SAAA,CAELxE,EAAAiD,iBAAAlD,EAAAb,EAEA,IAAAuF,GAAA3N,EAAAiN,SAAAU,QAEA,QAAAA,EAAA5N,OAAA,QAEAqE,IAAAuB,IACAvB,GAAAW,eAAAzE,KAAAqN,EAAA,IAAAnD,aAAAtB,EAKA,QAFAsG,IAAAxP,EAAAyP,OAAAtT,MAAAuT,WAAA,IAEAzB,EAAA,EAAAC,GAAAP,EAAA5N,OAA2CmO,GAAAD,EAAQA,IAEnD7J,GAAAuB,IACAvB,GAAAW,eAAAzE,KAAAqN,EAAAM,IAAAzD,aAAAtB,IAEA+E,EAAA,GAAAuB,GAAA,IAEAlL,GAAAwB,EAAAF,EAAA,GAEA2D,EAAAjJ,KAAA8D,GAAAW,gBACAyE,EAAAlJ,KAAAgE,GAAAS,gBAEAkC,EAAAsC,EAAAC,MAAA,IAGAD,EAAAoG,eAAA,EAAApG,EAAAhC,GACAiC,EAAAmG,eAAA,EAAAnG,EAAAjC,GAEAW,EAAA9B,IAEA8B,EAAA7M,GAAA2E,EAAA3E,GACA6M,EAAA9D,GAAAW,eAAAzE,KAAAiJ,GACArB,EAAA5D,GAAAS,eAAAzE,KAAAkJ,GAEAtB,EAAAhE,EAAAyD,KAAAC,IAAA2B,EAAArF,EAAAsF,EAAAtF,GAEAgE,EAAAtD,SAAA5E,EAAA4E,SAEA5E,EAAA4E,SAAAO,eAAAhJ,MAAAyT,eAEA1H,EAAA/C,aAAA,GAAA7E,KAAAN,EAAAiN,SAAA4C,OAAA5B,IACA/F,EAAA/C,aAAA,GAAA7E,KAAAN,EAAAiN,SAAA4C,OAAA5B,EAAA,KAIA5F,EAAAzF,SAAAc,KAAAwE,UAQI,IAAAlI,YAAA7D,OAAAsQ,OAAA,CAEJhE,EAAAkC,IAAAvC,EAAAxF,SAAA,IAAAwF,EAAAxF,SAAA,IAAAwF,EAAAxF,SAAA,OACA6F,EAAA+B,aAAAvB,EAEA,IAAAwB,IAAA,EAAAhC,EAAAlB,CAEAkB,GAAAvE,GAAAuG,GAEAhC,EAAAvE,GAAA,IAAAuE,EAAAvE,GAAA,IAEAiE,EAAA1B,IACA0B,EAAA9M,GAAA2E,EAAA3E,GACA8M,EAAAnJ,EAAAyJ,EAAAzJ,EAAAyL,GACAtC,EAAAlJ,EAAAwJ,EAAAxJ,EAAAwL,GACAtC,EAAAjE,EAAAuE,EAAAvE,EACAiE,EAAAnI,SAEAmI,EAAA9C,SAAArF,EAAAqF,SAEA8C,EAAA7C,MAAAtG,EAAAgB,EAAAsF,MAAAtG,EAAA2I,KAAAmI,IAAA3H,EAAAnJ,GAAAyJ,EAAAzJ,EAAAJ,EAAAwN,iBAAAxJ,SAAA,KAAA6F,EAAAlB,EAAA3I,EAAAwN,iBAAAxJ,SAAA,MACAuF,EAAA7C,MAAArG,EAAAe,EAAAsF,MAAArG,EAAA0I,KAAAmI,IAAA3H,EAAAlJ,GAAAwJ,EAAAxJ,EAAAL,EAAAwN,iBAAAxJ,SAAA,KAAA6F,EAAAlB,EAAA3I,EAAAwN,iBAAAxJ,SAAA,MAEAuF,EAAAvD,SAAA5E,EAAA4E,SAEAyD,EAAAzF,SAAAc,KAAAyE,KAcA,MANA0D,MAAA,GAEAxD,EAAAzF,SAAAkK,KAAAhG,GAIAuB","file":"Editor.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"assets/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t  var EditorUI, THREE, TweenTimeEditor, d3;\n\t  THREE = window.THREE;\n\t  TweenTimeEditor = __webpack_require__(4);\n\t  __webpack_require__(14);\n\t  d3 = __webpack_require__(5);\n\t  return window.EditorUI = EditorUI = (function() {\n\t    function EditorUI() {\n\t      this.initAdd = bind(this.initAdd, this);\n\t      this.initRemove = bind(this.initRemove, this);\n\t      this.onMenuCreated = bind(this.onMenuCreated, this);\n\t      var $container, getRaycaster, mouse, offset, plane, projector, selectedObject, selectedObjectPos;\n\t      this.tweenTime = window.tweenTime;\n\t      this.editor = new TweenTimeEditor(this.tweenTime, {\n\t        json_replacer: function(key, val) {\n\t          if (key === 'container') {\n\t            return void 0;\n\t          }\n\t          if (key === 'parent') {\n\t            return void 0;\n\t          }\n\t          if (key === 'children') {\n\t            return void 0;\n\t          }\n\t          if (key === 'object') {\n\t            return void 0;\n\t          }\n\t          if (key === 'classObject') {\n\t            return void 0;\n\t          }\n\t          return val;\n\t        }\n\t      });\n\t      this.onMenuCreated($('.timeline__menu'));\n\t      $container = $(window.app.containerWebgl);\n\t      offset = new THREE.Vector3();\n\t      projector = new THREE.Projector();\n\t      mouse = new THREE.Vector2();\n\t      selectedObject = false;\n\t      selectedObjectPos = new THREE.Vector3();\n\t      plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(3000, 2000, 8, 8), new THREE.MeshBasicMaterial({\n\t        color: 0xff0000,\n\t        opacity: 0.25,\n\t        transparent: true\n\t      }));\n\t      plane.visible = false;\n\t      this.editor.onSelect.add(function(item, addToSelection) {\n\t        return window.dispatchEvent(new Event('resize'));\n\t      });\n\t      getRaycaster = (function(_this) {\n\t        return function() {\n\t          var camera, raycaster, vector;\n\t          camera = window.activeCamera;\n\t          vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);\n\t          raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());\n\t          return raycaster;\n\t        };\n\t      })(this);\n\t      $container.mousedown((function(_this) {\n\t        return function(e) {\n\t          var element, intersects, raycaster;\n\t          e.preventDefault();\n\t          raycaster = getRaycaster();\n\t          intersects = raycaster.intersectObjects(window.app.scene.children);\n\t          if (intersects.length) {\n\t            element = intersects[0].object;\n\t            if (element._data) {\n\t              _this.editor.selectionManager.select(element._data);\n\t              selectedObject = element;\n\t              selectedObjectPos = selectedObject.position.clone();\n\t              intersects = raycaster.intersectObject(plane);\n\t              return offset.copy(intersects[0].point).sub(plane.position);\n\t            }\n\t          }\n\t        };\n\t      })(this));\n\t      $(window).mouseup((function(_this) {\n\t        return function(e) {\n\t          return selectedObject = false;\n\t        };\n\t      })(this));\n\t      $container.mousemove((function(_this) {\n\t        return function(e) {\n\t          var intersects, pos, posDiff, prop_x, prop_y, raycaster;\n\t          mouse.x = (e.clientX / $container.width()) * 2 - 1;\n\t          mouse.y = -(e.clientY / $container.height()) * 2 + 1;\n\t          if (!selectedObject) {\n\t            return;\n\t          }\n\t          if (!selectedObject._data) {\n\t            return;\n\t          }\n\t          prop_x = _this.tweenTime.getProperty('x', selectedObject._data);\n\t          prop_y = _this.tweenTime.getProperty('y', selectedObject._data);\n\t          raycaster = getRaycaster();\n\t          intersects = raycaster.intersectObject(plane);\n\t          pos = intersects[0].point.sub(offset);\n\t          posDiff = selectedObjectPos.clone().add(pos);\n\t          _this.tweenTime.setValue(prop_x, posDiff.x);\n\t          _this.tweenTime.setValue(prop_y, posDiff.y);\n\t          selectedObject._data._isDirty = true;\n\t          return _this.editor.timeline._isDirty = true;\n\t        };\n\t      })(this));\n\t    }\n\t\n\t    EditorUI.prototype.onMenuCreated = function($el) {\n\t      $el.append('<a class=\"menu-item menu-item--remove\">Remove</a>');\n\t      $el.prepend('<span class=\"menu-item\">Add<div class=\"submenu submenu--add\"></div></span>');\n\t      this.initAdd($el);\n\t      return this.initRemove($el);\n\t    };\n\t\n\t    EditorUI.prototype.initRemove = function($el) {\n\t      var data, selectionManager, self;\n\t      self = this;\n\t      selectionManager = self.editor.selectionManager;\n\t      data = window.tweenTime.data;\n\t      $el.find('.menu-item--remove').click(function(e) {\n\t        var datum, i, index, item, len, ref;\n\t        e.preventDefault();\n\t        ref = selectionManager.selection;\n\t        for (i = 0, len = ref.length; i < len; i++) {\n\t          item = ref[i];\n\t          datum = d3.select(item).datum();\n\t          index = data.indexOf(datum);\n\t          if (datum && datum.type && datum.id && index > -1) {\n\t            data.splice(index, 1);\n\t            if (datum.object) {\n\t              datum.object.destroy();\n\t              delete datum.object;\n\t            }\n\t          }\n\t        }\n\t        selectionManager.reset();\n\t        self.editor.render(false, false, true);\n\t      });\n\t    };\n\t\n\t    EditorUI.prototype.initAdd = function($el) {\n\t      var $container, $link, element, element_name, elements, self;\n\t      if (!window.ElementFactory) {\n\t        return;\n\t      }\n\t      $container = $el.find('.submenu--add');\n\t      elements = window.ElementFactory.elements;\n\t      self = this;\n\t      for (element_name in elements) {\n\t        element = elements[element_name];\n\t        $link = $('<a href=\"#\" data-key=\"' + element_name + '\">' + element_name + '</a>');\n\t        $container.append($link);\n\t      }\n\t      $container.find('a').click(function(e) {\n\t        var all_data, current_time, data, id, label, next_id;\n\t        e.preventDefault();\n\t        element_name = $(this).data('key');\n\t        if (ElementFactory.elements[element_name]) {\n\t          all_data = self.tweenTime.data;\n\t          next_id = all_data.length + 1;\n\t          id = \"item\" + next_id;\n\t          label = element_name + \" \" + next_id;\n\t          current_time = self.tweenTime.timer.time[0] / 1000;\n\t          data = {\n\t            isDirty: true,\n\t            id: id,\n\t            label: label,\n\t            type: element_name,\n\t            start: current_time,\n\t            end: current_time + 2,\n\t            collapsed: false,\n\t            properties: ElementFactory.getTypeProperties(element_name)\n\t          };\n\t          self.tweenTime.data.push(data);\n\t          self.editor.timeline._isDirty = true;\n\t        }\n\t      });\n\t    };\n\t\n\t    return EditorUI;\n\t\n\t  })();\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n\n/***/ 4:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = TweenTime.Editor;\n\n/***/ },\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = d3;\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author julianwa / https://github.com/julianwa\n\t */\n\t\n\tTHREE.RenderableObject = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableFace = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\tthis.v3 = new THREE.RenderableVertex();\n\t\n\t\tthis.normalModel = new THREE.Vector3();\n\t\n\t\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\t\tthis.vertexNormalsLength = 0;\n\t\n\t\tthis.color = new THREE.Color();\n\t\tthis.material = null;\n\t\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\t\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableVertex = function () {\n\t\n\t\tthis.position = new THREE.Vector3();\n\t\tthis.positionWorld = new THREE.Vector3();\n\t\tthis.positionScreen = new THREE.Vector4();\n\t\n\t\tthis.visible = true;\n\t\n\t};\n\t\n\tTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\t\n\t\tthis.positionWorld.copy( vertex.positionWorld );\n\t\tthis.positionScreen.copy( vertex.positionScreen );\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableLine = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\n\t\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\t\tthis.material = null;\n\t\n\t\tthis.z = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableSprite = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.z = 0;\n\t\n\t\tthis.rotation = 0;\n\t\tthis.scale = new THREE.Vector2();\n\t\n\t\tthis.material = null;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Projector = function () {\n\t\n\t\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\t\n\t\t_renderData = { objects: [], lights: [], elements: [] },\n\t\n\t\t_vector3 = new THREE.Vector3(),\n\t\t_vector4 = new THREE.Vector4(),\n\t\n\t\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t\t_boundingBox = new THREE.Box3(),\n\t\t_points3 = new Array( 3 ),\n\t\t_points4 = new Array( 4 ),\n\t\n\t\t_viewMatrix = new THREE.Matrix4(),\n\t\t_viewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_modelMatrix,\n\t\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_normalMatrix = new THREE.Matrix3(),\n\t\n\t\t_frustum = new THREE.Frustum(),\n\t\n\t\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\t\n\t\t//\n\t\n\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\t\n\t\t};\n\t\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\t\n\t\t};\n\t\n\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar RenderList = function () {\n\t\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar object = null;\n\t\t\tvar material = null;\n\t\n\t\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\t\tvar setObject = function ( value ) {\n\t\n\t\t\t\tobject = value;\n\t\t\t\tmaterial = object.material;\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\t\n\t\t\t\tnormals.length = 0;\n\t\t\t\tuvs.length = 0;\n\t\n\t\t\t};\n\t\n\t\t\tvar projectVertex = function ( vertex ) {\n\t\n\t\t\t\tvar position = vertex.position;\n\t\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\t\tvar positionScreen = vertex.positionScreen;\n\t\n\t\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\tvar invW = 1 / positionScreen.w;\n\t\n\t\t\t\tpositionScreen.x *= invW;\n\t\t\t\tpositionScreen.y *= invW;\n\t\t\t\tpositionScreen.z *= invW;\n\t\n\t\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\t\n\t\t\t};\n\t\n\t\t\tvar pushVertex = function ( x, y, z ) {\n\t\n\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t_vertex.position.set( x, y, z );\n\t\n\t\t\t\tprojectVertex( _vertex );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushNormal = function ( x, y, z ) {\n\t\n\t\t\t\tnormals.push( x, y, z );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushUv = function ( x, y ) {\n\t\n\t\t\t\tuvs.push( x, y );\n\t\n\t\t\t};\n\t\n\t\t\tvar checkTriangleVisibility = function ( v1, v2, v3 ) {\n\t\n\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\t\n\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\t\n\t\t\t\treturn _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) );\n\t\n\t\t\t};\n\t\n\t\t\tvar checkBackfaceCulling = function ( v1, v2, v3 ) {\n\t\n\t\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\t\n\t\t\t};\n\t\n\t\t\tvar pushLine = function ( a, b ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\n\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t_line.id = object.id;\n\t\t\t\t_line.v1.copy( v1 );\n\t\t\t\t_line.v2.copy( v2 );\n\t\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\t\n\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t};\n\t\n\t\t\tvar pushTriangle = function ( a, b, c ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\t\tvar v3 = _vertexPool[ c ];\n\t\n\t\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\t\n\t\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\t\n\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\tvar offset = arguments[ i ] * 3;\n\t\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\t\n\t\t\t\t\t\tnormal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\tvar offset2 = arguments[ i ] * 2;\n\t\n\t\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\t\tuv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_face.vertexNormalsLength = 3;\n\t\n\t\t\t\t\t_face.material = object.material;\n\t\n\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\treturn {\n\t\t\t\tsetObject: setObject,\n\t\t\t\tprojectVertex: projectVertex,\n\t\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\t\tpushVertex: pushVertex,\n\t\t\t\tpushNormal: pushNormal,\n\t\t\t\tpushUv: pushUv,\n\t\t\t\tpushLine: pushLine,\n\t\t\t\tpushTriangle: pushTriangle\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar renderList = new RenderList();\n\t\n\t\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\t\n\t\t\t_faceCount = 0;\n\t\t\t_lineCount = 0;\n\t\t\t_spriteCount = 0;\n\t\n\t\t\t_renderData.elements.length = 0;\n\t\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\t\n\t\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\t\n\t\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\t\n\t\t\t//\n\t\n\t\t\t_objectCount = 0;\n\t\n\t\t\t_renderData.objects.length = 0;\n\t\t\t_renderData.lights.length = 0;\n\t\n\t\t\tscene.traverseVisible( function ( object ) {\n\t\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\t\n\t\t\t\t\t_renderData.lights.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\tif ( object.material.visible === false ) return;\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\t\n\t\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t\t_object.id = object.id;\n\t\t\t\t\t\t_object.object = object;\n\t\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\t\n\t\t\t\t\t\t_renderData.objects.push( _object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t\tif ( sortObjects === true ) {\n\t\n\t\t\t\t_renderData.objects.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\t\n\t\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\trenderList.setObject( object );\n\t\n\t\t\t\t_modelMatrix = object.matrixWorld;\n\t\n\t\t\t\t_vertexCount = 0;\n\t\n\t\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar offsets = geometry.offsets;\n\t\n\t\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\t\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\t\n\t\t\t\t\t\t\tif ( offsets.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var o = 0; o < offsets.length; o ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar offset = offsets[ o ];\n\t\t\t\t\t\t\t\t\tvar index = offset.index;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\n\t\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\t\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\t\n\t\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ v ];\n\t\n\t\t\t\t\t\t\t_vector3.copy( vertex );\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\t\n\t\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\n\t\t\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t\t : object.material;\n\t\n\t\t\t\t\t\t\tif ( material === undefined ) continue;\n\t\n\t\t\t\t\t\t\tvar side = material.side;\n\t\n\t\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\t\n\t\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\t\n\t\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\t\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\t\n\t\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\t\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t_face.normalModel.negate();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\t\n\t\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalModel.negate();\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\t\n\t\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\t\n\t\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t\t_face.material = material;\n\t\n\t\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\n\t\t\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Line ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\t\t\tif ( attributes.position !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\t\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\n\t\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\t\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\t\n\t\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\t\n\t\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\t\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\t\n\t\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\t\n\t\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\t\n\t\t\t\t\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\t\n\t\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\t\n\t\t\t\t\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\t\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\t\tvar invW = 1 / _vector4.w;\n\t\n\t\t\t\t\t_vector4.z *= invW;\n\t\n\t\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\t\n\t\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t\t_sprite.object = object;\n\t\n\t\t\t\t\t\t_sprite.rotation = object.rotation;\n\t\n\t\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\t\n\t\t\t\t\t\t_sprite.material = object.material;\n\t\n\t\t\t\t\t\t_renderData.elements.push( _sprite );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( sortElements === true ) {\n\t\n\t\t\t\t_renderData.elements.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\treturn _renderData;\n\t\n\t\t};\n\t\n\t\t// Pools\n\t\n\t\tfunction getNextObjectInPool() {\n\t\n\t\t\tif ( _objectCount === _objectPoolLength ) {\n\t\n\t\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t\t_objectPool.push( object );\n\t\t\t\t_objectPoolLength ++;\n\t\t\t\t_objectCount ++;\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t\treturn _objectPool[ _objectCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextVertexInPool() {\n\t\n\t\t\tif ( _vertexCount === _vertexPoolLength ) {\n\t\n\t\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t\t_vertexPool.push( vertex );\n\t\t\t\t_vertexPoolLength ++;\n\t\t\t\t_vertexCount ++;\n\t\t\t\treturn vertex;\n\t\n\t\t\t}\n\t\n\t\t\treturn _vertexPool[ _vertexCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextFaceInPool() {\n\t\n\t\t\tif ( _faceCount === _facePoolLength ) {\n\t\n\t\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t\t_facePool.push( face );\n\t\t\t\t_facePoolLength ++;\n\t\t\t\t_faceCount ++;\n\t\t\t\treturn face;\n\t\n\t\t\t}\n\t\n\t\t\treturn _facePool[ _faceCount ++ ];\n\t\n\t\n\t\t}\n\t\n\t\tfunction getNextLineInPool() {\n\t\n\t\t\tif ( _lineCount === _linePoolLength ) {\n\t\n\t\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t\t_linePool.push( line );\n\t\t\t\t_linePoolLength ++;\n\t\t\t\t_lineCount ++\n\t\t\t\treturn line;\n\t\n\t\t\t}\n\t\n\t\t\treturn _linePool[ _lineCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextSpriteInPool() {\n\t\n\t\t\tif ( _spriteCount === _spritePoolLength ) {\n\t\n\t\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t\t_spritePool.push( sprite );\n\t\t\t\t_spritePoolLength ++;\n\t\t\t\t_spriteCount ++\n\t\t\t\treturn sprite;\n\t\n\t\t\t}\n\t\n\t\t\treturn _spritePool[ _spriteCount ++ ];\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction painterSort( a, b ) {\n\t\n\t\t\tif ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else if ( a.id !== b.id ) {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction clipLine( s1, s2 ) {\n\t\n\t\t\tvar alpha1 = 0, alpha2 = 1,\n\t\n\t\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t\t// Z = -1 and Z = +1, respectively.\n\t\t\tbc1near =  s1.z + s1.w,\n\t\t\tbc2near =  s2.z + s2.w,\n\t\t\tbc1far =  - s1.z + s1.w,\n\t\t\tbc2far =  - s2.z + s2.w;\n\t\n\t\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\t\n\t\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\t\treturn true;\n\t\n\t\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\t\n\t\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\t\treturn false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// The line segment spans at least one clip plane.\n\t\n\t\t\t\tif ( bc1near < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t} else if ( bc2near < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( bc1far < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t} else if ( bc2far < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( alpha2 < alpha1 ) {\n\t\n\t\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\n\n/***/ }\n\n/******/ });\n\n\n/** WEBPACK FOOTER **\n ** Editor.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4c3f4d10151ba0a0c039\n **/","define (require) ->\n  THREE = window.THREE\n  TweenTimeEditor = require 'TweenTime.Editor'\n  require 'vendors/three.js-extras/Projector'\n\n  d3 = require 'd3'\n\n  window.EditorUI = class EditorUI\n    constructor: () ->\n      @tweenTime = window.tweenTime\n      @editor = new TweenTimeEditor(@tweenTime, {\n        #onMenuCreated: @onMenuCreated,\n        json_replacer: (key, val) ->\n          # filter some circular values\n          if key == 'container' then return undefined\n          if key == 'parent' then return undefined\n          if key == 'children' then return undefined\n          if key == 'object' then return undefined\n          if key == 'classObject' then return undefined\n          return val\n      })\n      @onMenuCreated($('.timeline__menu'))\n\n      $container = $(window.app.containerWebgl)\n      offset = new THREE.Vector3()\n      projector = new THREE.Projector()\n      mouse = new THREE.Vector2()\n      selectedObject = false\n      selectedObjectPos = new THREE.Vector3()\n\n      plane = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry( 3000, 2000, 8, 8 ),\n        new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.25, transparent: true } )\n      )\n      plane.visible = false\n\n\n      @editor.onSelect.add((item, addToSelection) ->\n        # Trigger window resize in order to resize the 3d render.\n        window.dispatchEvent(new Event('resize'))\n      )\n\n      getRaycaster = () =>\n        camera = window.activeCamera\n        vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera )\n        raycaster = new THREE.Raycaster(camera.position, vector.sub( camera.position ).normalize())\n        return raycaster\n\n      $container.mousedown (e) =>\n        e.preventDefault()\n        raycaster = getRaycaster()\n        intersects = raycaster.intersectObjects( window.app.scene.children )\n\n        if intersects.length\n          element = intersects[0].object\n          if element._data\n            @editor.selectionManager.select(element._data)\n            selectedObject = element\n            selectedObjectPos = selectedObject.position.clone()\n\n            intersects = raycaster.intersectObject(plane)\n            offset.copy(intersects[ 0 ].point).sub(plane.position)\n      $(window).mouseup (e) =>\n        selectedObject = false\n\n      $container.mousemove (e) =>\n        mouse.x = ( e.clientX / $container.width() ) * 2 - 1\n        mouse.y = -( e.clientY / $container.height() ) * 2 + 1\n\n        if !selectedObject then return\n        if !selectedObject._data then return\n        prop_x = @tweenTime.getProperty('x', selectedObject._data)\n        prop_y = @tweenTime.getProperty('y', selectedObject._data)\n\n        raycaster = getRaycaster()\n        intersects = raycaster.intersectObject( plane )\n        pos = intersects[ 0 ].point.sub( offset )\n\n        posDiff = selectedObjectPos.clone().add(pos)\n\n        @tweenTime.setValue(prop_x, posDiff.x)\n        @tweenTime.setValue(prop_y, posDiff.y)\n        selectedObject._data._isDirty = true\n        @editor.timeline._isDirty = true\n\n\n    onMenuCreated: ($el) =>\n      $el.append('<a class=\"menu-item menu-item--remove\">Remove</a>')\n      $el.prepend('<span class=\"menu-item\">Add<div class=\"submenu submenu--add\"></div></span>')\n\n      @initAdd($el)\n      @initRemove($el)\n\n    initRemove: ($el) =>\n      self = this\n      selectionManager = self.editor.selectionManager\n      data = window.tweenTime.data\n      $el.find('.menu-item--remove').click (e) ->\n        e.preventDefault()\n        for item in selectionManager.selection\n          # only remove full objects.\n          datum = d3.select(item).datum()\n          index = data.indexOf(datum)\n          if datum && datum.type && datum.id && index > -1\n            data.splice(index, 1)\n            # also remove the three.js object\n            if datum.object\n              datum.object.destroy()\n              delete datum.object\n\n        selectionManager.reset()\n        self.editor.render(false, false, true)\n        return\n      return\n\n    initAdd: ($el) =>\n      if !window.ElementFactory then return\n      $container = $el.find('.submenu--add')\n      elements = window.ElementFactory.elements\n      self = this\n\n      for element_name, element of elements\n        $link = $('<a href=\"#\" data-key=\"' + element_name + '\">' + element_name + '</a>')\n        $container.append($link)\n\n      $container.find('a').click (e) ->\n        e.preventDefault()\n        element_name = $(this).data('key')\n        if ElementFactory.elements[element_name]\n          all_data = self.tweenTime.data\n          next_id = all_data.length + 1\n          id = \"item\" + next_id\n          label = element_name + \" \" + next_id\n          current_time = self.tweenTime.timer.time[0] / 1000\n          data =\n            isDirty: true\n            id: id\n            label: label\n            type: element_name\n            start: current_time\n            end: current_time + 2\n            collapsed: false\n            #properties: []\n            #options: window.ElementFactory.elements[element_name].default_attributes()\n            #properties: window.ElementFactory.elements[element_name].default_properties(current_time)\n            properties: ElementFactory.getTypeProperties(element_name)\n\n          self.tweenTime.data.push(data)\n          self.editor.timeline._isDirty = true\n        return\n      return\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/scripts/app/EditorUI.coffee\n **/","module.exports = TweenTime.Editor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"TweenTime.Editor\"\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = d3;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableFace = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.normalModel = new THREE.Vector3();\n\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = new THREE.Color();\n\tthis.material = null;\n\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n//\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\n};\n\n//\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\t//\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n\t//\n\n\tvar RenderList = function () {\n\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar object = null;\n\t\tvar material = null;\n\n\t\tvar normalMatrix = new THREE.Matrix3();\n\n\t\tvar setObject = function ( value ) {\n\n\t\t\tobject = value;\n\t\t\tmaterial = object.material;\n\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\n\t\t\tnormals.length = 0;\n\t\t\tuvs.length = 0;\n\n\t\t};\n\n\t\tvar projectVertex = function ( vertex ) {\n\n\t\t\tvar position = vertex.position;\n\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\tvar positionScreen = vertex.positionScreen;\n\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / positionScreen.w;\n\n\t\t\tpositionScreen.x *= invW;\n\t\t\tpositionScreen.y *= invW;\n\t\t\tpositionScreen.z *= invW;\n\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\n\t\t};\n\n\t\tvar pushVertex = function ( x, y, z ) {\n\n\t\t\t_vertex = getNextVertexInPool();\n\t\t\t_vertex.position.set( x, y, z );\n\n\t\t\tprojectVertex( _vertex );\n\n\t\t};\n\n\t\tvar pushNormal = function ( x, y, z ) {\n\n\t\t\tnormals.push( x, y, z );\n\n\t\t};\n\n\t\tvar pushUv = function ( x, y ) {\n\n\t\t\tuvs.push( x, y );\n\n\t\t};\n\n\t\tvar checkTriangleVisibility = function ( v1, v2, v3 ) {\n\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\n\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\treturn _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) );\n\n\t\t};\n\n\t\tvar checkBackfaceCulling = function ( v1, v2, v3 ) {\n\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t};\n\n\t\tvar pushLine = function ( a, b ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\n\t\t\t_line = getNextLineInPool();\n\n\t\t\t_line.id = object.id;\n\t\t\t_line.v1.copy( v1 );\n\t\t\t_line.v2.copy( v2 );\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\n\t\t\t_line.material = object.material;\n\n\t\t\t_renderData.elements.push( _line );\n\n\t\t};\n\n\t\tvar pushTriangle = function ( a, b, c ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\tvar v3 = _vertexPool[ c ];\n\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\n\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\n\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t_face.id = object.id;\n\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tvar offset = arguments[ i ] * 3;\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\n\t\t\t\t\tnormal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\tvar offset2 = arguments[ i ] * 2;\n\n\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\tuv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\t_face.vertexNormalsLength = 3;\n\n\t\t\t\t_face.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t}\n\n\t\t};\n\n\t\treturn {\n\t\t\tsetObject: setObject,\n\t\t\tprojectVertex: projectVertex,\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\tpushVertex: pushVertex,\n\t\t\tpushNormal: pushNormal,\n\t\t\tpushUv: pushUv,\n\t\t\tpushLine: pushLine,\n\t\t\tpushTriangle: pushTriangle\n\t\t}\n\n\t};\n\n\tvar renderList = new RenderList();\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\t_faceCount = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t//\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\n\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.id = object.id;\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\tvar geometry = object.geometry;\n\n\t\t\trenderList.setObject( object );\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\n\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.index !== undefined ) {\n\n\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\tif ( offsets.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( var o = 0; o < offsets.length; o ++ ) {\n\n\t\t\t\t\t\t\t\tvar offset = offsets[ o ];\n\t\t\t\t\t\t\t\tvar index = offset.index;\n\n\t\t\t\t\t\t\t\tfor ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ v ];\n\n\t\t\t\t\t\t_vector3.copy( vertex );\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\n\t\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t : object.material;\n\n\t\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\n\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\n\t\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\tif ( attributes.position !== undefined ) {\n\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( attributes.index !== undefined ) {\n\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\t\tvar vertices = object.geometry.vertices;\n\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t\t_vector4.z *= invW;\n\n\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\n\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t_sprite.object = object;\n\n\t\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\n\t\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) {\n\n\t\t\t_renderData.elements.sort( painterSort );\n\n\t\t}\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFaceInPool() {\n\n\t\tif ( _faceCount === _facePoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t_facePool.push( face );\n\t\t\t_facePoolLength ++;\n\t\t\t_faceCount ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _facePool[ _faceCount ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/scripts/vendors/three.js-extras/Projector.js\n ** module id = 14\n ** module chunks = 0\n **/"],"sourceRoot":""}